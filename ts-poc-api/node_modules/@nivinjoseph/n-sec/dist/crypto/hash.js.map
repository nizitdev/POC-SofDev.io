{"version":3,"file":"hash.js","sourceRoot":"","sources":["../../src/crypto/hash.ts"],"names":[],"mappings":";;AAAA,0DAAiD;AACjD,8BAA4B;AAC5B,iCAAiC;AAIjC,MAAa,IAAI;IAEb,gBAAwB,CAAC;IAGlB,MAAM,CAAC,MAAM,CAAC,KAAa;QAE9B,mBAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,cAAc,EAAE,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAE9F,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;QAErB,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAC3B,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;IAC7D,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,KAAa,EAAE,IAAY;QAErD,mBAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,cAAc,EAAE,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAC9F,mBAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,cAAc,EAAE,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,mBAAmB,EAAE,CAAC,CAAC;QAE5F,KAAK,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;QACrB,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAEnB,MAAM,OAAO,GAAG,CAAC,GAAW,EAAE,EAAE;YAE5B,IAAI,GAAG,GAAG,EAAE,CAAC;YACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE;gBAC/B,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;YACvB,OAAO,GAAG,CAAC;QACf,CAAC,CAAC;QAEF,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;QACpC,MAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAElC,MAAM,WAAW,GAAG,uBAAuB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,YAAY,EAAE,WAAW,CAAC,CAAC;QAE3F,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;IACpC,CAAC;CACJ;AAvCD,oBAuCC","sourcesContent":["import { given } from \"@nivinjoseph/n-defensive\";\nimport \"@nivinjoseph/n-ext\";\nimport * as Crypto from \"crypto\";\n\n\n// public\nexport class Hash\n{\n    private constructor() { }\n    \n\n    public static create(value: string): Promise<string>\n    {\n        given(value, \"value\").ensureHasValue().ensureIsString().ensure(t => !t.isEmptyOrWhiteSpace());\n        \n        value = value.trim();\n        \n        const hash = Crypto.createHash(\"sha512\");\n        hash.update(value, \"utf8\");\n        return Promise.resolve(hash.digest(\"hex\").toUpperCase());\n    }\n    \n    public static createUsingSalt(value: string, salt: string): Promise<string>\n    {\n        given(value, \"value\").ensureHasValue().ensureIsString().ensure(t => !t.isEmptyOrWhiteSpace());\n        given(salt, \"salt\").ensureHasValue().ensureIsString().ensure(t => !t.isEmptyOrWhiteSpace());\n\n        value = value.trim();\n        salt = salt.trim();\n        \n        const reverse = (val: string) =>\n        {\n            let rev = \"\";\n            for (let i = 0; i < val.length; i++)\n                rev = val[i] + rev;\n            return rev;\n        };\n        \n        const valueReverse = reverse(value);\n        const saltReverse = reverse(salt);\n\n        const saltedValue = \"{1}{0}{2}{1}{3}{1}{2}\".format(value, salt, valueReverse, saltReverse);\n        \n        return Hash.create(saltedValue);\n    }\n}"]}