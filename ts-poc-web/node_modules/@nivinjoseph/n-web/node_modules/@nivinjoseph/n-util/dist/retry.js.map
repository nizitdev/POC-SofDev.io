{"version":3,"file":"retry.js","sourceRoot":"","sources":["../src/retry.ts"],"names":[],"mappings":"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","sourcesContent":["import { given } from \"n-defensive\";\n\n// public\nexport abstract class Retry // static class\n{\n    private constructor() { }\n\n\n    public static make<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, onErrors?: Function[]): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(onErrors, \"onErrors\").ensureIsArray().ensure(t => t.length > 0).ensure(t => t.every(u => typeof(u) === \"function\"));\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await func(...p);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (onErrors && onErrors.every(t => !(error instanceof t)))\n                        break;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n\n    public static makeWithDelay<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, delayMS: number, onErrors?: Function[]): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(onErrors, \"onErrors\").ensureIsArray().ensure(t => t.length > 0).ensure(t => t.every(u => typeof (u) === \"function\"));\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            let executeWithDelay = (delay: number) =>\n            {\n                return new Promise((resolve, reject) =>\n                {\n                    setTimeout(() =>\n                    {\n                        func(...p)\n                            .then(t => resolve(t))\n                            .catch(err => reject(err));\n                    }, delay);\n                });\n\n            };\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await executeWithDelay(attempts === 1 ? 0 : delayMS);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (onErrors && onErrors.every(t => !(error instanceof t)))\n                        break;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n\n    public static makeWithExponentialBackoff<T>(func: (...params: any[]) => Promise<T>, numberOfRetries: number, onErrors?: Function[]): (...params: any[]) => Promise<T>\n    {\n        given(func, \"func\").ensureHasValue().ensureIsFunction();\n        given(numberOfRetries, \"numberOfRetries\").ensureHasValue().ensureIsNumber().ensure(t => t > 0);\n        given(onErrors, \"onErrors\").ensureIsArray().ensure(t => t.length > 0).ensure(t => t.every(u => typeof (u) === \"function\"));\n        \n        let numberOfAttempts = numberOfRetries + 1;\n        \n        let result = async function (...p: any[]): Promise<T>\n        {\n            let successful = false;\n            let attempts = 0;\n            let delayMS = 0;\n\n            let funcResult: any;\n            let error: any;\n\n            let executeWithDelay = (delay: number) =>\n            {\n                return new Promise((resolve, reject) =>\n                {\n                    setTimeout(() =>\n                    {\n                        func(...p)\n                            .then(t => resolve(t))\n                            .catch(err => reject(err));\n                    }, delay);\n                });\n\n            };\n\n            while (successful === false && attempts < numberOfAttempts)\n            {\n                attempts++;\n\n                try \n                {\n                    funcResult = await executeWithDelay(delayMS);\n                    successful = true;\n                }\n                catch (err)\n                {\n                    error = err;\n                    if (onErrors && onErrors.every(t => !(error instanceof t)))\n                        break;\n                    delayMS = (delayMS + Retry.getRandomInt(200, 500)) * attempts;\n                }\n            }\n\n            if (successful)\n                return funcResult;\n\n            throw error;\n        };\n\n        return result;\n    }\n\n    \n    private static getRandomInt(min: number, max: number): number\n    {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min)) + min; // The maximum is exclusive and the minimum is inclusive\n    }\n}"]}